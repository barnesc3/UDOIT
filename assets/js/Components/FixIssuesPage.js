import React, { useState, useEffect } from 'react';
import FixIssuesFilters from './FixIssuesFilters';
import FixIssuesList from './FixIssuesList';
import FixIssuesContentPreview from './FixIssuesContentPreview';
import UfixitWidget from './UfixitWidget'
import * as Html from '../Services/Html'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * - contentItemList: A list of all the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted (formatIssueData) and stored in a list for filtering.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issue: The issue as it is stored in the database
**/

export default function FixIssuesPage({
  t,
  settings,
  initialSeverity = '',
  contentItemList,
  addContentItem,
  report,
  sections,
  setReport,
  addMessage,
  updateReportIssue,
  sessionIssues,
  updateSessionIssue,
  disableReview })
{

  // Define the kinds of filters that will be available to the user
  const FILTER = {
    TYPE: {
      SEVERITY: 'SEVERITY',
      CONTENT_TYPE: 'CONTENT_TYPE',
      RESOLUTION: 'RESOLUTION',
      MODULE: 'MODULE',
    },
    ALL: 'ALL',
    ISSUE: 'ISSUE',
    POTENTIAL: 'POTENTIAL',
    SUGGESTION: 'SUGGESTION',
    PAGE: 'PAGE',
    ASSIGNMENT: 'ASSIGNMENT',
    ANNOUNCEMENT: 'ANNOUNCEMENT',
    DISCUSSION_TOPIC: 'DISCUSSION_TOPIC',
    DISCUSSION_FORUM: 'DISCUSSION_FORUM',
    FILE: 'FILE',
    QUIZ: 'QUIZ',
    SYLLABUS: 'SYLLABUS',
    MODULE: 'MODULE',
    ACTIVE: 'ACTIVE',
    FIXED: 'FIXED',
    RESOLVED: 'RESOLVED',
  }

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = {
    LOADING: 0,
    FIXIT: 1,
    LEARN: 2,
    LIST: 3,
    NO_RESULTS: 4,
  }

  const ISSUE_STATE = {
    UNCHANGED: 0,
    SAVING: 1,
    RESOLVING: 2,
    SAVED: 3,
    RESOLVED: 4,
    ERROR: 5,
  }

  const [activeIssue, setActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [editedElement, setEditedElement] = useState(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)
  const [viewInfo, setViewInfo] = useState(false)

  // The database stores and returns certain issue data, but it needs additional attributes in order to
  // be really responsive on the front end. This function adds those attributes and stores the database
  // information in the "issue" attribute.
  const formatIssueData = (issue) => {

    let issueSeverity = FILTER.ISSUE
    // PHPAlly returns a type of 'error' or 'suggestion'
    if(issue.type == 'suggestion') {
      issueSeverity = FILTER.SUGGESTION
    }
    
    let issueContentType = FILTER.ALL
    let issueSectionIds = []

    // PHPAlly returns a contentItemId that we can use to get the content type
    let tempContentItem = getContentById(issue.contentItemId)
    if(tempContentItem) {
      let tempContentType = tempContentItem.contentType
      if(tempContentType == 'page') {
        issueContentType = FILTER.PAGE
      }
      else if(tempContentType == 'assignment') {
        issueContentType = FILTER.ASSIGNMENT
      }
      else if(tempContentType == 'announcement') {
        issueContentType = FILTER.ANNOUNCEMENT
      }
      else if(tempContentType == 'discussion_topic') {
        issueContentType = FILTER.DISCUSSION_TOPIC
      }
      else if(tempContentType == 'discussion_forum') {
        issueContentType = FILTER.DISCUSSION_FORUM
      }
      else if(tempContentType == 'file') {
        issueContentType = FILTER.FILE
      }
      else if(tempContentType == 'quiz') {
        issueContentType = FILTER.QUIZ
      }
      else if(tempContentType == 'syllabus') {
        issueContentType = FILTER.SYLLABUS
      }
      else if(tempContentType == 'module') {
        issueContentType = FILTER.MODULE
      }

      // See if the issue is listed in one of the sections
      /* TODO: Find a more consistent way to filter this that works with less bespoke data.
        In Canvas, the modules and moduleItems have names and links, but do not have the
        contentItemId, which is necessary to match the issue to the content. The only current
        data that matches are the moduleItem's page_url are the contentItem's lmsContentId,
        which are both the same internal link URL. */
      if(sections && sections.length > 0) {
        sections.forEach((section) => {
          let tempSectionId = section.id
          section.items.forEach((item) => {
            if(item.page_url === tempContentItem.lmsContentId) {
              issueSectionIds.push(tempSectionId.toString())
            }
          })
        })
      }
    }

    let issueResolution = FILTER.ACTIVE
    // PHPAlly returns a status of 1 for fixed issues and 2 for resolved issues
    if(issue.status == 1) {
      issueResolution = FILTER.FIXED
    }
    else if(issue.status == 2) {
      issueResolution = FILTER.RESOLVED
    }

    let currentState = ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[issue.id]) {
      currentState = sessionIssues[issue.id]
    }

    return {
      id: issue.id,
      issue: Object.assign({}, issue),
      severity: issueSeverity,
      status: issueResolution,
      sectionIds: issueSectionIds,
      keywords: createKeywords(issue, tempContentItem),
      scanRuleLabel: t(`rule.label.${issue.scanRuleId}`),
      contentId: tempContentItem.lmsContentId,
      contentType: issueContentType,
      contentTypeLabel: t(`content.${tempContentItem.contentType}`),
      contentTitle: tempContentItem.title,
      contentUrl: tempContentItem.url,
      currentState: currentState, 
    }
  }

  // Call the formatIssueData function when the report changes to make sure every issue has all the necessary attributes
  useEffect(() => {
    let tempIssues = Object.assign({}, report.issues)
    let tempFormattedIssues = []

    for (const [key, value] of Object.entries(tempIssues)) {
      let issue = formatIssueData(value)
      tempFormattedIssues.push(issue)
    }

    tempFormattedIssues.sort((a, b) => {
      return (a.contentTypeLabel.toLowerCase() < b.contentTypeLabel.toLowerCase()) ? -1 : 1
    })

    setUnfilteredIssues(tempFormattedIssues)
  }, [report])

  // The initialSeverity prop is used when clicking a "Fix Issues" button from the main dashboard.
  useEffect(() => {
    let tempSeverity = initialSeverity || FILTER.ALL
    setActiveFilters(Object.assign({}, defaultFilters, {[FILTER.TYPE.SEVERITY]: tempSeverity}))
  }, [initialSeverity])

  const getFilteredContent = () => {
    let filteredList = [];
    const tempFilters = Object.assign({}, activeFilters);

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of unfilteredIssues) {

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue;
      }

      // Do not include this issue if it doesn't match the content type filter
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== issue.contentType) {
        continue;
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== issue.status) {
        continue;
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL && !issue.sectionIds.includes(tempFilters[FILTER.TYPE.MODULE].toString())) {
        continue;
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ');
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }
      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.contentTypeLabel.toLowerCase() < b.contentTypeLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent()
    setFilteredIssues(tempFilteredContent)
    setActiveIssue(null)

    // If nothing matches the filters, show the no results view
    if(tempFilteredContent.length === 0) {
      setWidgetState(WIDGET_STATE.NO_RESULTS)
    }
    else {
      // Otherwise, view the list
      setWidgetState(WIDGET_STATE.LIST)
    }

  }, [activeFilters, searchTerm])

  const loadContentItem = (contentItemId) => {
    let api = new Api(settings)
    api.getIssueContent(activeIssue.id)
    .then((response) => {
      return response.json()
    }).then((data) => {
      if(data?.data?.contentItem) {
        const newContentItem = data.data.contentItem
        addContentItem(newContentItem)
        if(activeIssue?.issue?.contentItemId === contentItemId) {
          setActiveContentItem(newContentItem)
        }
      }
    })
  }

  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      if(widgetState === WIDGET_STATE.LIST) {
        return
      }
      setWidgetState(WIDGET_STATE.NO_RESULTS)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)

    // If we've already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issue.contentItemId
    if(contentItemList[contentItemId]) {
      setActiveContentItem(contentItemList[contentItemId])
      return
    }

    // Otherwise, clear the old content and download the content for this issue
    setActiveContentItem(null)
    loadContentItem(contentItemId)

  }, [activeIssue])  

  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null) => {

    if(activeIssue) {
      let tempIssue = Object.assign({}, activeIssue)
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }

    let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
      if(issue.id === issueId) {
        let tempIssue = Object.assign({}, issue)
        tempIssue.currentState = state
        return tempIssue
      }
      return issue
    })
    setUnfilteredIssues(tempUnfilteredIssues)

    let tempFilteredIssues = filteredIssues.map((issue) => {
      if(issue.id === issueId) {
        let tempIssue = Object.assign({}, issue)
        tempIssue.currentState = state
        return tempIssue
      }
      return issue
    })
    setFilteredIssues(tempFilteredIssues)

    // If the issue is resolved or saved, reload the associated content item
    if(state === ISSUE_STATE.SAVED || state === ISSUE_STATE.RESOLVED) {
      let contentItemId = null
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === issueId) {
          contentItemId = issue.issue.contentItemId
        }
      })
      if(contentItemId) {
        loadContentItem(contentItemId)
      }
    }

    updateSessionIssue(issueId, state)
  }

  const updateIssue = (newIssue) => {
    const tempReport = Object.assign({}, report)
    tempReport.issues = tempReport.issues.map((issue) => {
      if (issue.id === newIssue.id) {
        const tempIssue = formatIssueData(newIssue)
        setActiveIssue(tempIssue)
        return tempIssue
      }
      return issue
    })
    setReport(tempReport)
  }

  const handleIssueSave = (issue) => {

    updateActiveSessionIssue(issue.id, ISSUE_STATE.SAVING)

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.saveIssue(issue)
        .then((responseStr) => responseStr.json())
        .then((response) => {

          // If the save falied, show the relevant error message
          if (response.data.failed) {
            updateActiveSessionIssue(issue.id, ISSUE_STATE.ERROR)
            response.messages.forEach((msg) => addMessage(msg))
            
            if (Array.isArray(response.data.issues)) {
              response.data.issues.forEach((issue) => {
                addMessage({
                  severity: 'error',
                  message: t(`form.error.${issue.ruleId}`)
                })
              })
            }

            if (Array.isArray(response.data.errors)) {
              response.data.errors.forEach((error) => {
                addMessage({
                  severity: 'error',
                  message: error
                })
              })
            }
          }
          else {
            
            // If the save was successful, show the success message
            response.messages.forEach((msg) => addMessage(msg))

            if (response.data.issue) {
              // Update the report object by rescanning the content
              const newIssue = Object.assign({}, issue, response.data.issue)
              api.scanContent(newIssue.contentItemId)
                .then((responseStr) => responseStr.json())
                .then((res) => {
                  updateActiveSessionIssue(newIssue.id, ISSUE_STATE.SAVED)
                  setActiveIssue(formatIssueData(newIssue))
                  updateReportIssue(newIssue, res.data)
                })
            }
            else {
              updateActiveSessionIssue(issue.id, ISSUE_STATE.SAVED)
              setActiveIssue(formatIssueData(issue))
            }
          }
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, ISSUE_STATE.ERROR)
    }
  }

  const handleIssueResolve = (issue) => {

    updateActiveSessionIssue(issue.id, ISSUE_STATE.RESOLVING)

    let tempIssue = Object.assign({}, issue)
    if (tempIssue.status) {
      tempIssue.status = false
      tempIssue.newHtml = Html.toString(Html.removeClass(tempIssue.sourceHtml, 'phpally-ignore'))
    }
    else {
      tempIssue.status = 2
      tempIssue.newHtml = Html.toString(Html.addClass(tempIssue.sourceHtml, 'phpally-ignore'))
    }

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.resolveIssue(tempIssue)
        .then((responseStr) => responseStr.json())
        .then((response) => {      

          response.messages.forEach((msg) => addMessage(msg))
        
          if (response.data.issue) {
            const newIssue = { ...tempIssue, ...response.data.issue }
            const newReport = response.data.report

            // update activeIssue
            newIssue.sourceHtml = newIssue.newHtml
            newIssue.newHtml = ''
            // Get updated report
            api.scanContent(newIssue.contentItemId)
            .then((responseStr) => responseStr.json())
            .then((res) => {
              // update activeIssue locally
              updateActiveSessionIssue(tempIssue.id, ISSUE_STATE.RESOLVED)
              setActiveIssue(formatIssueData(newIssue))
              updateReportIssue(newIssue, res.data)
            })
          }
          else {
            updateActiveSessionIssue(tempIssue.id, ISSUE_STATE.RESOLVED)
            setActiveIssue(formatIssueData(tempIssue))
          }
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}));
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }

    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id);

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1);
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1;
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0;
    }
    setActiveIssue(filteredIssues[newIndex]);
  }

  const toggleListView = () => {
    if (widgetState === WIDGET_STATE.LIST) {
      if(activeIssue) {
        setWidgetState(WIDGET_STATE.FIXIT)
      }
      else {
        setWidgetState(WIDGET_STATE.NO_RESULTS)
      }
    }
    else {
      setWidgetState(WIDGET_STATE.LIST)
      setActiveIssue(null)
      setActiveContentItem(null)
    }
  }

  const getContentById = (contentId) => {
    return Object.assign({}, report.contentItems[contentId]);
  }

  const createKeywords = (issue, contentItem) => {
    let keywords = [];

    if(issue?.scanRuleId) {
      keywords.push(t(`rule.label.${issue.scanRuleId}`).toLowerCase());
    }
    if(contentItem?.contentType) {
      keywords.push(t(`label.${contentItem.contentType}`).toLowerCase());
    }
    if(contentItem?.title) {
      keywords.push(contentItem.title.toLowerCase());
    }

    return keywords.join(' ');
  }

  return (
    <>
      <FixIssuesFilters
        t={t}
        settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
        sections={sections}
        activeFilters={activeFilters}
        updateActiveFilters={updateActiveFilters}
        searchTerm={searchTerm}
        handleSearchTerm={setSearchTerm}
      />
      <div className="ufixit-page-divider">
        <section className="ufixit-widget-container">
          { widgetState === WIDGET_STATE.LIST ? (
            <FixIssuesList
              t={t}
              settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
              filteredIssues={filteredIssues}
              setActiveIssue={setActiveIssue}
            />
          ) : activeIssue ? (  
              <UfixitWidget
                t={t}
                settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
                ISSUE_STATE={ISSUE_STATE}
                viewInfo={viewInfo}
                setViewInfo={setViewInfo}
                severity={activeIssue.severity}
                activeIssue={activeIssue}
                setActiveIssue={setActiveIssue}
                setEditedElement={setEditedElement}
                formatIssueData={formatIssueData}
                handleIssueResolve={handleIssueResolve}
                handleIssueSave={handleIssueSave}
                toggleListView={toggleListView}
                listLength={filteredIssues.length}
                nextIssue={nextIssue}
              />
          ) : (
            <h2>No Issues Found</h2>
          )}
        </section>
        <section className="ufixit-content-container">
          <FixIssuesContentPreview
            t={t}
            settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
            activeIssue={activeIssue}
            activeContentItem={activeContentItem}
            editedElement={editedElement}
          />
        </section>
      </div>
    </>
  )
}